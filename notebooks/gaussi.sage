#-----------------------------------------------------------------------------------------#
#
# Internal (showtime stuff)
#
#-----------------------------------------------------------------------------------------#

def _add_caption(v1,v2,cl):
    if (v1,v2) == (0,0):
        return 1/2, "$0$"
    caption = "$"
    if v1 != 0:
        caption += str(v1)
    if v2 == 0:
        caption += "$"
    elif v2 == 1:
        caption += "+ i$"
    elif v2 == -1:
        caption += "- i$"
    else:
        if v2 > 0:
            caption += "+" + str(v2) + "i$"
        elif v2 < 0:
            caption += str(v2) + "i$"
    if v1 < 0 or v2 < 0:
        inc = -1/2
    else:
        inc = 1/2
    return text(caption,(v1 + inc, v2 + inc), color = cl)

def _add_basis_vectors(v1,v2,cl):
    return arrow((0,0), (v1,v2),color=cl,width=1) + arrow((0,0),(-v2,v1),color=cl,width=1)

def _add_grid(m,n,a,b,v1,v2,cl):
    grph = Graphics()
    u,v = a+v1,b+v2
    if u >= -m and u <= m and v >= -n and v <=n:
        grph += line([(a,b),(u,v)],color=cl,linestyle = ':')
    u,v = a-v2,b+v1
    if u >= -m and u <= m and v >= -n and v <=n:
        grph += line([(a,b),(u,v)],color=cl,linestyle = ':')
    return grph

def _gaussi_ideal(m,n,g,basis,grid,cl):
    J = ideal(g) # principal ideal generated by g
    grph = Graphics()
    v1, v2 = re_im(g) # basis
    add_caption = lambda : _add_caption(v1,v2,cl) # v1, v2 and cl are known at this time
    add_basis_vectors = lambda : _add_basis_vectors(v1,v2,cl) # v1, v2 and cl are known at this time
    add_grid = lambda a,b : _add_grid(m,n,a,b,v1,v2,cl) # m, n, v1, v2 and cl are known at this time
    for a in range (-m,m+1):
        for b in range (-n,n+1):
            #if ZZ[i](a + b*i) in J:
            if a + b*i in J:
                pt = point((a,b),rgbcolor=Color(cl),size=40)
                grph += pt
                if grid == True:
                    grph += add_grid(a,b)
            else:
                pt = point((a,b))
                grph += pt
    if basis == True:
        grph += add_caption() + add_basis_vectors()
    return grph

#------------------------------------------------------------------------------------------
#
# Interface
#
#------------------------------------------------------------------------------------------
def gaussi_lattice(width,height): # the whole thing
    grph = Graphics()
    for a in range (-width,width+1):
        for b in range (-height,height+1):
            grph += point((a,b))
    return grph
#------------------------------------------------------------------------------------------
def gaussi_ideal_lattice(g,basis=True,grid=True,width=8,height=8,cl='orange'): # superimposes the ideal
    return _gaussi_ideal(width,height,g,basis,grid,cl)
#------------------------------------------------------------------------------------------
def gaussi_circle(z,g,cl='blue'): # "euclidean neighborhood"
    z1,z2 = re_im(z)
    return circle((z1,z2), abs(g), color = cl) + point((z1,z2),color = cl, size=40) + _add_caption(z1,z2,cl)
#------------------------------------------------------------------------------------------
def showtime(grph,ratio=1,size=8): # Just showtime :)
    show(grph,aspect_ratio=ratio,figsize=size)
#------------------------------------------------------------------------------------------
def re_im(w): # w \in ZZ[i]
    return real_part(w), imag_part(w)
#------------------------------------------------------------------------------------------
def quad(z,beta): # || z - beta*(a + b*i) || \in ZZ[a,b])
    a,b = var('a,b')
    assume(a,'integer')
    assume(b,'integer')
    return norm(z - beta*(a + b*i))
#------------------------------------------------------------------------------------------
def diop(poly,k): # poly \in ZZ[a,b], k \in Integer; returns integer solution(s) to poly == k
    fvars = poly.free_variables() # independent of variable names
    return solve([SR(ZZ[fvars](poly)) == k],fvars)
#------------------------------------------------------------------------------------------
def find_factor(w,u):
    __z = var('__z')
    return solve([w*__z == u],__z)[0].rhs()
#------------------------------------------------------------------------------------------
def from_ints(c): # c \in ZZ^2
    return c[0] + c[1]*i
#------------------------------------------------------------------------------------------
def euclidean_norm(z): # z \in ZZ[i]
    return int(norm(z)) # hack
#------------------------------------------------------------------------------------------
def is_euclidean_division(z,w,q,r):
    return z == q*w + r and euclidean_norm(w2) > euclidean_norm(r)